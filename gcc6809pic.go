package main

import (
	"bufio"
	"flag"
	"fmt"
	"log"
	"os"
	"regexp"
	"strings"
)

var NAME = flag.String("name", "noname", "module name to create")
var MEM = flag.Uint("mem", 256, "default memory size for module")

type AsmLine struct {
	Filename string
	LineNum  int
	Line     string
	Label    string
	Opcode   string
	Args     string
	Remark   string
}

// Remark Lines:
// Blank Space, possibly followed by `;` or `*` and anything.
var RemarkLinePattern = regexp.MustCompile(`^\s*([;*].*)?$`)
var LabelLinePattern = regexp.MustCompile(`^([A-Za-z_.@$#][A-Za-z0-9_.@$#?]*)[:]?\s*([*;].*)?$`)
var FullLinePattern = regexp.MustCompile(`^(([A-Za-z_.@$#][A-Za-z0-9_.@$#?]*)[:]?)?\s+([A-Za-z0-9._=]+)\s*(.*?)\s*$`)

func main() {
	log.SetFlags(0)
	flag.Parse()
	var z []*AsmLine
	for _, filename := range flag.Args() {
		z = append(z, Slurp(filename)...)
	}
	EmitPrelude()
	Emit(Tweak(z))
	EmitPostlude()
}

func Slurp(filename string) (z []*AsmLine) {
	fd := Value(os.Open(filename))
	scanner := bufio.NewScanner(fd)
	i := 0
	for scanner.Scan() {
		i++
		line := scanner.Text()
		line = strings.TrimRight(line, " \t\r\n")
		if m := RemarkLinePattern.FindStringSubmatch(line); m != nil {
			z = append(z, &AsmLine{
				Filename: filename,
				LineNum:  i,
				Line:     line,
				Remark:   line,
			})
			continue
		}
		if m := LabelLinePattern.FindStringSubmatch(line); m != nil {
			label := m[1]
			z = append(z, &AsmLine{
				Filename: filename,
				LineNum:  i,
				Line:     line,
				Label:    label,
			})
			continue
		}
		if m := FullLinePattern.FindStringSubmatch(line); m != nil {
			label, opcode, args := m[2], m[3], m[4]
			z = append(z, &AsmLine{
				Filename: filename,
				LineNum:  i,
				Line:     line,
				Label:    label,
				Opcode:   strings.ToLower(opcode),
				Args:     args,
			})
			continue
		}
		log.Fatalf("FATAL (%q:%d) gcc6809pic cannot parse %q", filename, i, line)
	}
	Check(scanner.Err(), filename)
	return
}

var ExtendedLabelArgPattern = regexp.MustCompile(`^([_L][A-Za-z0-9_.]*)(\s.*)?$`)
var ImmediateLabelArgPattern = regexp.MustCompile(`^([#][A-Za-z_][A-Za-z0-9_.]*)(\s.*)?$`)
var FirstWordPattern = regexp.MustCompile(`^(\S+)(.*)$`)
var IdentifierPattern = regexp.MustCompile(`^([A-Za-z_][A-Za-z0-9_.]*)$`)

func FirstWord(s string) string {
    m := FirstWordPattern.FindStringSubmatch(s)
    if m == nil {
        log.Panic("Expected a first argument: %q", s)
    }
    return m[1]
}

func Tweak(a []*AsmLine) (z []*AsmLine) {
	for _, it := range a {
		switch {
		case it.Opcode == "jmp":
				dup := *it
				dup.Opcode = "lbra"
				dup.Args = Format("%s  ;PIC_FIXED: %s", dup.Args, it.Line)
				z = append(z, &dup)
				continue

		case it.Opcode == "jsr":
			front := FirstWord(it.Args)
			if front == ",x" || front == ",y" || front == ",u" || front == ",s" {
				goto KEEP
			}

            isIdentifier := IdentifierPattern.FindStringSubmatch(front)
            if isIdentifier == nil {
                log.Panicf("(%s:%d) Case not handled: %q", it.Filename, it.LineNum, it.Line)
            }

			dup := *it // makes a copy of the struct
			dup.Opcode = "lbsr"
			dup.Args = Format("%s  ;PIC_FIXED: %s", front, it.Line)
			z = append(z, &dup)
			continue

		case it.Opcode == "ldd" || it.Opcode == "ldx" || it.Opcode == "ldy" || it.Opcode == "ldu" || it.Opcode == "lds":
			if m := ImmediateLabelArgPattern.FindStringSubmatch(it.Args); m != nil {
				dup := *it
				dup.Opcode = Format("lea%c", it.Opcode[2])
				dup.Args = Format("%s,pcr  ;PIC_FIXED: %s", m[1][1:], it.Line)
				z = append(z, &dup)
				continue
			}
			if m := ExtendedLabelArgPattern.FindStringSubmatch(it.Args); m != nil {
				dup := *it
				dup.Opcode = Format("lea%c", it.Opcode[2])
				dup.Args = Format("%s,pcr  ;PIC_FIXED: %s", m[1], it.Line)
				z = append(z, &dup)
				deref := *it
				deref.Label = ""
				deref.Opcode = it.Opcode
				deref.Args = Format(",%c  ;PIC_DEREF:", it.Opcode[2])
				z = append(z, &deref)
				continue
			}
		}
	KEEP:
		z = append(z, it)
	}
	return
}

func Emit(a []*AsmLine) {
	for _, it := range a {
		switch {
		case it.Opcode == ".module" || it.Opcode == ".area" || it.Opcode == ".globl":
			fmt.Printf("%-60s *** %s ***\n", "***", it.Line)

		case it.Label == "" && it.Opcode == "":
			fmt.Printf("%-60s *** %s ***\n", "***", it.Line)

		case it.Label != "":
			fmt.Printf("%-20s %-12s %s\n", it.Label+":", it.Opcode, it.Args)

		default:
			fmt.Printf("%-20s %-12s %s\n", "", it.Opcode, it.Args)
		}
	}
}

func EmitPrelude() {
	mem := Format("%d", *MEM)
	s := PRELUDE
	s = strings.Replace(s, "<-name->", *NAME, -1)
	s = strings.Replace(s, "<-mem->", mem, -1)
	fmt.Println(s)
}
func EmitPostlude() {
	fmt.Println(POSTLUDE)
}

const PRELUDE = `
*** Generated by gcc6809pic ***

 nam <-name->
 ttl <-name->

 ifp1
 use defsfile
 endc

tylg                set       Prgrm+Objct
atrv                set       ReEnt+rev
rev                 set       $01
edition             set       1


size                equ       <-mem->

                    mod       eom,name,tylg,atrv,start,size

name                fcs       /<-name->/
                    fcb       edition

start:              lbsr _main
                    tfr x,d     ; X has return status, but we want it in B.
                    os9 F$Exit
zombie:
                    bra zombie  ; F$Exit should never return.
`

const POSTLUDE = `
 emod
eom equ *
 end
*** Generated by gcc6809pic ***
`
